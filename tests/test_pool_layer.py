import unittest
import numpy as np

from multilayer_perceptron.layers import MaxPooling2DLayer

class MaxPoolingLayerTestCase(unittest.TestCase):
  def test_output_shape(self):
    pool_layer = MaxPooling2DLayer(pool_shape=(2, 2), stride=(2, 2))
    pool_layer.input_shape = (3, 4, 4)
    expected_output_shape = (3, 2, 2)
    np.testing.assert_almost_equal(pool_layer.output_shape, expected_output_shape)
  
  def test_forward(self):
    pool_layer = MaxPooling2DLayer(pool_shape=(2, 2), stride=(2, 2))
    pool_layer.input_shape = (2, 4, 4)

    input_data = np.array([[[[0.91021023, 0.92432799, 0.27602576, 0.91480548],
                             [0.38655604, 0.74260366, 0.22080052, 0.25369164],
                             [0.04282349, 0.17704447, 0.53831581, 0.30279841],
                             [0.71938112, 0.97396707, 0.75316661, 0.38019115]],

                            [[0.49061511, 0.20274269, 0.05692643, 0.17050202],
                             [0.99553276, 0.39912681, 0.12844578, 0.84903129],
                             [0.90030611, 0.1487966 , 0.71885341, 0.27105137],
                             [0.68446919, 0.15986949, 0.67201857, 0.41192824]]],


                           [[[0.87652575, 0.61157011, 0.67696502, 0.4732961 ],
                             [0.0904357 , 0.859055  , 0.76763915, 0.53074221],
                             [0.26315197, 0.33150374, 0.84116252, 0.80309719],
                             [0.2403605 , 0.87224349, 0.75974217, 0.4979698 ]],

                            [[0.2904952 , 0.9345095 , 0.69687609, 0.89470272],
                             [0.59592491, 0.93261248, 0.81026418, 0.44818005],
                             [0.08025646, 0.9674674 , 0.32961566, 0.34033245],
                             [0.51957857, 0.16102257, 0.49246615, 0.80461477]]],


                           [[[0.04523589, 0.22112282, 0.04209679, 0.34846226],
                             [0.27768041, 0.29525397, 0.22424148, 0.45949707],
                             [0.17955062, 0.28806679, 0.85652106, 0.0386315 ],
                             [0.72666068, 0.13286699, 0.21837408, 0.90610584]],

                            [[0.01822199, 0.6141171 , 0.01247734, 0.57808399],
                             [0.19867562, 0.11772099, 0.05782396, 0.29954874],
                             [0.51446437, 0.25497872, 0.33849874, 0.42808105],
                             [0.86099132, 0.19350063, 0.01332086, 0.03156302]]]])

    output = pool_layer.forward(input_data)

    expected_output = np.array([[[[0.92432799, 0.91480548],
                                  [0.97396707, 0.75316661]],

                                 [[0.99553276, 0.84903129],
                                  [0.90030611, 0.71885341]]],


                                [[[0.87652575, 0.76763915],
                                  [0.87224349, 0.84116252]],

                                 [[0.9345095 , 0.89470272],
                                  [0.9674674 , 0.80461477]]],


                                [[[0.29525397, 0.45949707],
                                  [0.72666068, 0.90610584]],

                                 [[0.6141171 , 0.57808399],
                                  [0.86099132, 0.42808105]]]])

    np.testing.assert_almost_equal(output, expected_output)

  def test_backward(self):
    pool_layer = MaxPooling2DLayer(pool_shape=(2, 2), stride=(2, 2))
    pool_layer.input_shape = (2, 4, 4)

    pool_layer.prev_input = np.array([[[[0.91021023, 0.92432799, 0.27602576, 0.91480548],
                                        [0.38655604, 0.74260366, 0.22080052, 0.25369164],
                                        [0.04282349, 0.17704447, 0.53831581, 0.30279841],
                                        [0.71938112, 0.97396707, 0.75316661, 0.38019115]],

                                       [[0.49061511, 0.20274269, 0.05692643, 0.17050202],
                                        [0.99553276, 0.39912681, 0.12844578, 0.84903129],
                                        [0.90030611, 0.1487966 , 0.71885341, 0.27105137],
                                        [0.68446919, 0.15986949, 0.67201857, 0.41192824]]],


                                      [[[0.87652575, 0.61157011, 0.67696502, 0.4732961 ],
                                        [0.0904357 , 0.859055  , 0.76763915, 0.53074221],
                                        [0.26315197, 0.33150374, 0.84116252, 0.80309719],
                                        [0.2403605 , 0.87224349, 0.75974217, 0.4979698 ]],

                                        [[0.2904952 , 0.9345095 , 0.69687609, 0.89470272],
                                        [0.59592491, 0.93261248, 0.81026418, 0.44818005],
                                        [0.08025646, 0.9674674 , 0.32961566, 0.34033245],
                                        [0.51957857, 0.16102257, 0.49246615, 0.80461477]]],


                                      [[[0.04523589, 0.22112282, 0.04209679, 0.34846226],
                                        [0.27768041, 0.29525397, 0.22424148, 0.45949707],
                                        [0.17955062, 0.28806679, 0.85652106, 0.0386315 ],
                                        [0.72666068, 0.13286699, 0.21837408, 0.90610584]],

                                        [[0.01822199, 0.6141171 , 0.01247734, 0.57808399],
                                        [0.19867562, 0.11772099, 0.05782396, 0.29954874],
                                        [0.51446437, 0.25497872, 0.33849874, 0.42808105],
                                        [0.86099132, 0.19350063, 0.01332086, 0.03156302]]]])
    

    pool_layer.prev_output = np.array([[[[0.92432799, 0.91480548],
                                         [0.97396707, 0.75316661]],

                                        [[0.99553276, 0.84903129],
                                         [0.90030611, 0.71885341]]],


                                       [[[0.87652575, 0.76763915],
                                         [0.87224349, 0.84116252]],

                                        [[0.9345095 , 0.89470272],
                                         [0.9674674 , 0.80461477]]],


                                       [[[0.29525397, 0.45949707],
                                         [0.72666068, 0.90610584]],

                                        [[0.6141171 , 0.57808399],
                                         [0.86099132, 0.42808105]]]])

    output_gradient = np.array([[[[0.13085117, 0.18246388],
                                  [0.37126957, 0.67374209]],

                                 [[0.11509206, 0.3673585 ],
                                  [0.90148577, 0.19527868]]],


                                [[[0.48354551, 0.34717379],
                                  [0.22030296, 0.34954863]],

                                 [[0.14646034, 0.09990422],
                                  [0.40423024, 0.98383649]]],


                                [[[0.81816942, 0.8384738 ],
                                  [0.79516388, 0.17637085]],

                                 [[0.20222018, 0.05045746],
                                  [0.25691303, 0.55403448]]]])

    input_gradient = pool_layer.backward(output_gradient)

    expected_input_gradient = np.array([[[[0.        , 0.13085117, 0.        , 0.18246388],
                                          [0.        , 0.        , 0.        , 0.        ],
                                          [0.        , 0.        , 0.        , 0.        ],
                                          [0.        , 0.37126957, 0.67374209, 0.        ]],

                                         [[0.        , 0.        , 0.        , 0.        ],
                                          [0.11509206, 0.        , 0.        , 0.3673585 ],
                                          [0.90148577, 0.        , 0.19527868, 0.        ],
                                          [0.        , 0.        , 0.        , 0.        ]]],


                                        [[[0.48354551, 0.        , 0.        , 0.        ],
                                          [0.        , 0.        , 0.34717379, 0.        ],
                                          [0.        , 0.        , 0.34954863, 0.        ],
                                          [0.        , 0.22030296, 0.        , 0.        ]],

                                         [[0.        , 0.14646034, 0.        , 0.09990422],
                                          [0.        , 0.        , 0.        , 0.        ],
                                          [0.        , 0.40423024, 0.        , 0.        ],
                                          [0.        , 0.        , 0.        , 0.98383649]]],


                                        [[[0.        , 0.        , 0.        , 0.        ],
                                          [0.        , 0.81816942, 0.        , 0.8384738 ],
                                          [0.        , 0.        , 0.        , 0.        ],
                                          [0.79516388, 0.        , 0.        , 0.17637085]],

                                         [[0.        , 0.20222018, 0.        , 0.05045746],
                                          [0.        , 0.        , 0.        , 0.        ],
                                          [0.        , 0.        , 0.        , 0.55403448],
                                          [0.25691303, 0.        , 0.        , 0.        ]]]])

    np.testing.assert_almost_equal(input_gradient, expected_input_gradient)

if __name__ == '__main__':
  unittest.main()